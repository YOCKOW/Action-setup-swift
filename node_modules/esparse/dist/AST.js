'use strict';

exports.forEachChild = forEachChild;
exports.Identifier = Identifier;
exports.NumberLiteral = NumberLiteral;
exports.StringLiteral = StringLiteral;
exports.TemplatePart = TemplatePart;
exports.RegularExpression = RegularExpression;
exports.BooleanLiteral = BooleanLiteral;
exports.NullLiteral = NullLiteral;
exports.Script = Script;
exports.Module = Module;
exports.ThisExpression = ThisExpression;
exports.SuperKeyword = SuperKeyword;
exports.SequenceExpression = SequenceExpression;
exports.AssignmentExpression = AssignmentExpression;
exports.SpreadExpression = SpreadExpression;
exports.YieldExpression = YieldExpression;
exports.ConditionalExpression = ConditionalExpression;
exports.BinaryExpression = BinaryExpression;
exports.UpdateExpression = UpdateExpression;
exports.UnaryExpression = UnaryExpression;
exports.MemberExpression = MemberExpression;
exports.MetaProperty = MetaProperty;
exports.CallExpression = CallExpression;
exports.TemplateExpression = TemplateExpression;
exports.TaggedTemplateExpression = TaggedTemplateExpression;
exports.NewExpression = NewExpression;
exports.ParenExpression = ParenExpression;
exports.ObjectLiteral = ObjectLiteral;
exports.ComputedPropertyName = ComputedPropertyName;
exports.PropertyDefinition = PropertyDefinition;
exports.ObjectPattern = ObjectPattern;
exports.PatternProperty = PatternProperty;
exports.ArrayPattern = ArrayPattern;
exports.PatternElement = PatternElement;
exports.PatternRestElement = PatternRestElement;
exports.MethodDefinition = MethodDefinition;
exports.ArrayLiteral = ArrayLiteral;
exports.Block = Block;
exports.LabelledStatement = LabelledStatement;
exports.ExpressionStatement = ExpressionStatement;
exports.Directive = Directive;
exports.EmptyStatement = EmptyStatement;
exports.VariableDeclaration = VariableDeclaration;
exports.VariableDeclarator = VariableDeclarator;
exports.ReturnStatement = ReturnStatement;
exports.BreakStatement = BreakStatement;
exports.ContinueStatement = ContinueStatement;
exports.ThrowStatement = ThrowStatement;
exports.DebuggerStatement = DebuggerStatement;
exports.IfStatement = IfStatement;
exports.DoWhileStatement = DoWhileStatement;
exports.WhileStatement = WhileStatement;
exports.ForStatement = ForStatement;
exports.ForInStatement = ForInStatement;
exports.ForOfStatement = ForOfStatement;
exports.WithStatement = WithStatement;
exports.SwitchStatement = SwitchStatement;
exports.SwitchCase = SwitchCase;
exports.TryStatement = TryStatement;
exports.CatchClause = CatchClause;
exports.FunctionDeclaration = FunctionDeclaration;
exports.FunctionExpression = FunctionExpression;
exports.FormalParameter = FormalParameter;
exports.RestParameter = RestParameter;
exports.FunctionBody = FunctionBody;
exports.ArrowFunctionHead = ArrowFunctionHead;
exports.ArrowFunction = ArrowFunction;
exports.ClassDeclaration = ClassDeclaration;
exports.ClassExpression = ClassExpression;
exports.ClassBody = ClassBody;
exports.EmptyClassElement = EmptyClassElement;
exports.ClassField = ClassField;
exports.ImportCall = ImportCall;
exports.ImportDeclaration = ImportDeclaration;
exports.NamespaceImport = NamespaceImport;
exports.NamedImports = NamedImports;
exports.DefaultImport = DefaultImport;
exports.ImportSpecifier = ImportSpecifier;
exports.ExportDeclaration = ExportDeclaration;
exports.ExportDefault = ExportDefault;
exports.ExportNameList = ExportNameList;
exports.ExportNamespace = ExportNamespace;
exports.ExportDefaultFrom = ExportDefaultFrom;
exports.ExportSpecifier = ExportSpecifier;
exports.Annotation = Annotation;
exports.Comment = Comment;

function isNode(x) {
  return x !== null && typeof x === 'object' && typeof x.type === 'string';
}

function forEachChild(node, fn) {
  let keys = Object.keys(node);
  let stop = {};
  for (let i = 0; i < keys.length; ++i) {
    let key = keys[i];
    let value = node[key];
    if (Array.isArray(value)) {
      for (let j = 0; j < value.length; ++j) {
        if (isNode(value[j])) if (fn(value[j], key, j, stop) === stop) return ;
      }
    } else if (isNode(value)) {
      if (fn(value, key, null, stop) === stop) return ;
    }
  }
}

function Identifier(value, context) {
  this.type = 'Identifier';
  this.start = -1;
  this.end = -1;
  this.value = value;
  this.context = context;
}

function NumberLiteral(value, suffix) {
  this.type = 'NumberLiteral';
  this.start = -1;
  this.end = -1;
  this.value = value;
  this.suffix = suffix;
}

function StringLiteral(value) {
  this.type = 'StringLiteral';
  this.start = -1;
  this.end = -1;
  this.value = value;
}

function TemplatePart(value, raw, isEnd) {
  this.type = 'TemplatePart';
  this.start = -1;
  this.end = -1;
  this.value = value;
  this.raw = raw;
  this.templateEnd = isEnd;
}

function RegularExpression(value, flags) {
  this.type = 'RegularExpression';
  this.start = -1;
  this.end = -1;
  this.value = value;
  this.flags = flags;
}

function BooleanLiteral(value) {
  this.type = 'BooleanLiteral';
  this.start = -1;
  this.end = -1;
  this.value = value;
}

function NullLiteral() {
  this.type = 'NullLiteral';
  this.start = -1;
  this.end = -1;
}

function Script(statements) {
  this.type = 'Script';
  this.start = -1;
  this.end = -1;
  this.statements = statements;
}

function Module(statements) {
  this.type = 'Module';
  this.start = -1;
  this.end = -1;
  this.statements = statements;
}

function ThisExpression() {
  this.type = 'ThisExpression';
  this.start = -1;
  this.end = -1;
}

function SuperKeyword() {
  this.type = 'SuperKeyword';
  this.start = -1;
  this.end = -1;
}

function SequenceExpression(list) {
  this.type = 'SequenceExpression';
  this.start = -1;
  this.end = -1;
  this.expressions = list;
}

function AssignmentExpression(left, op, right) {
  this.type = 'AssignmentExpression';
  this.start = -1;
  this.end = -1;
  this.left = left;
  this.operator = op;
  this.right = right;
}

function SpreadExpression(expr) {
  this.type = 'SpreadExpression';
  this.start = -1;
  this.end = -1;
  this.expression = expr;
}

function YieldExpression(expr, delegate) {
  this.type = 'YieldExpression';
  this.start = -1;
  this.end = -1;
  this.delegate = delegate;
  this.expression = expr;
}

function ConditionalExpression(test, cons, alt) {
  this.type = 'ConditionalExpression';
  this.start = -1;
  this.end = -1;
  this.test = test;
  this.consequent = cons;
  this.alternate = alt;
}

function BinaryExpression(left, op, right) {
  this.type = 'BinaryExpression';
  this.start = -1;
  this.end = -1;
  this.left = left;
  this.operator = op;
  this.right = right;
}

function UpdateExpression(op, expr, prefix) {
  this.type = 'UpdateExpression';
  this.start = -1;
  this.end = -1;
  this.operator = op;
  this.expression = expr;
  this.prefix = prefix;
}

function UnaryExpression(op, expr) {
  this.type = 'UnaryExpression';
  this.start = -1;
  this.end = -1;
  this.operator = op;
  this.expression = expr;
}

function MemberExpression(obj, prop) {
  this.type = 'MemberExpression';
  this.start = -1;
  this.end = -1;
  this.object = obj;
  this.property = prop;
}

function MetaProperty(left, right) {
  this.type = 'MetaProperty';
  this.start = -1;
  this.end = -1;
  this.left = left;
  this.right = right;
}

function CallExpression(callee, args, trailingComma) {
  this.type = 'CallExpression';
  this.start = -1;
  this.end = -1;
  this.callee = callee;
  this.arguments = args;
  this.trailingComma = trailingComma;
}

function TemplateExpression(parts) {
  this.type = 'TemplateExpression';
  this.start = -1;
  this.end = -1;
  this.parts = parts;
}

function TaggedTemplateExpression(tag, template) {
  this.type = 'TaggedTemplateExpression';
  this.start = -1;
  this.end = -1;
  this.tag = tag;
  this.template = template;
}

function NewExpression(callee, args, trailingComma) {
  this.type = 'NewExpression';
  this.start = -1;
  this.end = -1;
  this.callee = callee;
  this.arguments = args;
  this.trailingComma = trailingComma;
}

function ParenExpression(expr) {
  this.type = 'ParenExpression';
  this.start = -1;
  this.end = -1;
  this.expression = expr;
}

function ObjectLiteral(props, comma) {
  this.type = 'ObjectLiteral';
  this.start = -1;
  this.end = -1;
  this.properties = props;
  this.trailingComma = comma;
}

function ComputedPropertyName(expr) {
  this.type = 'ComputedPropertyName';
  this.start = -1;
  this.end = -1;
  this.expression = expr;
}

function PropertyDefinition(name, expr) {
  this.type = 'PropertyDefinition';
  this.start = -1;
  this.end = -1;
  this.name = name;
  this.expression = expr;
}

function ObjectPattern(props, comma) {
  this.type = 'ObjectPattern';
  this.start = -1;
  this.end = -1;
  this.properties = props;
  this.trailingComma = comma;
}

function PatternProperty(name, pattern, initializer) {
  this.type = 'PatternProperty';
  this.start = -1;
  this.end = -1;
  this.name = name;
  this.pattern = pattern;
  this.initializer = initializer;
}

function ArrayPattern(elements, comma) {
  this.type = 'ArrayPattern';
  this.start = -1;
  this.end = -1;
  this.elements = elements;
  this.trailingComma = comma;
}

function PatternElement(pattern, initializer) {
  this.type = 'PatternElement';
  this.start = -1;
  this.end = -1;
  this.pattern = pattern;
  this.initializer = initializer;
}

function PatternRestElement(pattern) {
  this.type = 'PatternRestElement';
  this.start = -1;
  this.end = -1;
  this.pattern = pattern;
}

function MethodDefinition(isStatic, kind, name, params, body) {
  this.type = 'MethodDefinition';
  this.start = -1;
  this.end = -1;
  this.static = isStatic;
  this.kind = kind;
  this.name = name;
  this.params = params;
  this.body = body;
}

function ArrayLiteral(elements, comma) {
  this.type = 'ArrayLiteral';
  this.start = -1;
  this.end = -1;
  this.elements = elements;
  this.trailingComma = comma;
}

function Block(statements) {
  this.type = 'Block';
  this.start = -1;
  this.end = -1;
  this.statements = statements;
}

function LabelledStatement(label, statement) {
  this.type = 'LabelledStatement';
  this.start = -1;
  this.end = -1;
  this.label = label;
  this.statement = statement;
}

function ExpressionStatement(expr) {
  this.type = 'ExpressionStatement';
  this.start = -1;
  this.end = -1;
  this.expression = expr;
}

function Directive(value, expr) {
  this.type = 'Directive';
  this.start = -1;
  this.end = -1;
  this.value = value;
  this.expression = expr;
}

function EmptyStatement() {
  this.type = 'EmptyStatement';
  this.start = -1;
  this.end = -1;
}

function VariableDeclaration(kind, list) {
  this.type = 'VariableDeclaration';
  this.start = -1;
  this.end = -1;
  this.kind = kind;
  this.declarations = list;
}

function VariableDeclarator(pattern, initializer) {
  this.type = 'VariableDeclarator';
  this.start = -1;
  this.end = -1;
  this.pattern = pattern;
  this.initializer = initializer;
}

function ReturnStatement(arg) {
  this.type = 'ReturnStatement';
  this.start = -1;
  this.end = -1;
  this.argument = arg;
}

function BreakStatement(label) {
  this.type = 'BreakStatement';
  this.start = -1;
  this.end = -1;
  this.label = label;
}

function ContinueStatement(label) {
  this.type = 'ContinueStatement';
  this.start = -1;
  this.end = -1;
  this.label = label;
}

function ThrowStatement(expr) {
  this.type = 'ThrowStatement';
  this.start = -1;
  this.end = -1;
  this.expression = expr;
}

function DebuggerStatement() {
  this.type = 'DebuggerStatement';
  this.start = -1;
  this.end = -1;
}

function IfStatement(test, cons, alt) {
  this.type = 'IfStatement';
  this.start = -1;
  this.end = -1;
  this.test = test;
  this.consequent = cons;
  this.alternate = alt;
}

function DoWhileStatement(body, test) {
  this.type = 'DoWhileStatement';
  this.start = -1;
  this.end = -1;
  this.body = body;
  this.test = test;
}

function WhileStatement(test, body) {
  this.type = 'WhileStatement';
  this.start = -1;
  this.end = -1;
  this.test = test;
  this.body = body;
}

function ForStatement(initializer, test, update, body) {
  this.type = 'ForStatement';
  this.start = -1;
  this.end = -1;
  this.initializer = initializer;
  this.test = test;
  this.update = update;
  this.body = body;
}

function ForInStatement(left, right, body) {
  this.type = 'ForInStatement';
  this.start = -1;
  this.end = -1;
  this.left = left;
  this.right = right;
  this.body = body;
}

function ForOfStatement(async, left, right, body) {
  this.type = 'ForOfStatement';
  this.start = -1;
  this.end = -1;
  this.async = async;
  this.left = left;
  this.right = right;
  this.body = body;
}

function WithStatement(object, body) {
  this.type = 'WithStatement';
  this.start = -1;
  this.end = -1;
  this.object = object;
  this.body = body;
}

function SwitchStatement(desc, cases) {
  this.type = 'SwitchStatement';
  this.start = -1;
  this.end = -1;
  this.descriminant = desc;
  this.cases = cases;
}

function SwitchCase(test, cons) {
  this.type = 'SwitchCase';
  this.start = -1;
  this.end = -1;
  this.test = test;
  this.consequent = cons;
}

function TryStatement(block, handler, fin) {
  this.type = 'TryStatement';
  this.start = -1;
  this.end = -1;
  this.block = block;
  this.handler = handler;
  this.finalizer = fin;
}

function CatchClause(param, body) {
  this.type = 'CatchClause';
  this.start = -1;
  this.end = -1;
  this.param = param;
  this.body = body;
}

function FunctionDeclaration(kind, identifier, params, body) {
  this.type = 'FunctionDeclaration';
  this.start = -1;
  this.end = -1;
  this.kind = kind;
  this.identifier = identifier;
  this.params = params;
  this.body = body;
}

function FunctionExpression(kind, identifier, params, body) {
  this.type = 'FunctionExpression';
  this.start = -1;
  this.end = -1;
  this.kind = kind;
  this.identifier = identifier;
  this.params = params;
  this.body = body;
}

function FormalParameter(pattern, initializer) {
  this.type = 'FormalParameter';
  this.start = -1;
  this.end = -1;
  this.pattern = pattern;
  this.initializer = initializer;
}

function RestParameter(identifier) {
  this.type = 'RestParameter';
  this.start = -1;
  this.end = -1;
  this.identifier = identifier;
}

function FunctionBody(statements) {
  this.type = 'FunctionBody';
  this.start = -1;
  this.end = -1;
  this.statements = statements;
}

function ArrowFunctionHead(params) {
  this.type = 'ArrowFunctionHead';
  this.start = -1;
  this.end = -1;
  this.parameters = params;
}

function ArrowFunction(kind, params, body) {
  this.type = 'ArrowFunction';
  this.start = -1;
  this.end = -1;
  this.kind = kind;
  this.params = params;
  this.body = body;
}

function ClassDeclaration(identifier, base, body) {
  this.type = 'ClassDeclaration';
  this.start = -1;
  this.end = -1;
  this.identifier = identifier;
  this.base = base;
  this.body = body;
}

function ClassExpression(identifier, base, body) {
  this.type = 'ClassExpression';
  this.start = -1;
  this.end = -1;
  this.identifier = identifier;
  this.base = base;
  this.body = body;
}

function ClassBody(elems) {
  this.type = 'ClassBody';
  this.start = -1;
  this.end = -1;
  this.elements = elems;
}

function EmptyClassElement() {
  this.type = 'EmptyClassElement';
  this.start = -1;
  this.end = -1;
}

function ClassField(isStatic, name, initializer) {
  this.type = 'ClassField';
  this.start = -1;
  this.end = -1;
  this.static = isStatic;
  this.name = name;
  this.initializer = initializer;
}

function ImportCall(argument) {
  this.type = 'ImportCall';
  this.start = -1;
  this.end = -1;
  this.argument = argument;
}

function ImportDeclaration(imports, from) {
  this.type = 'ImportDeclaration';
  this.start = -1;
  this.end = -1;
  this.imports = imports;
  this.from = from;
}

function NamespaceImport(identifier) {
  this.type = 'NamespaceImport';
  this.start = -1;
  this.end = -1;
  this.identifier = identifier;
}

function NamedImports(specifiers) {
  this.type = 'NamedImports';
  this.start = -1;
  this.end = -1;
  this.specifiers = specifiers;
}

function DefaultImport(identifier, imports) {
  this.type = 'DefaultImport';
  this.start = -1;
  this.end = -1;
  this.identifier = identifier;
  this.imports = imports;
}

function ImportSpecifier(imported, local) {
  this.type = 'ImportSpecifier';
  this.start = -1;
  this.end = -1;
  this.imported = imported;
  this.local = local;
}

function ExportDeclaration(declaration) {
  this.type = 'ExportDeclaration';
  this.start = -1;
  this.end = -1;
  this.declaration = declaration;
}

function ExportDefault(binding) {
  this.type = 'ExportDefault';
  this.start = -1;
  this.end = -1;
  this.binding = binding;
}

function ExportNameList(specifiers, from) {
  this.type = 'ExportNameList';
  this.start = -1;
  this.end = -1;
  this.specifiers = specifiers;
  this.from = from;
}

function ExportNamespace(identifier, from) {
  this.type = 'ExportNamespace';
  this.start = -1;
  this.end = -1;
  this.identifier = identifier;
  this.from = from;
}

function ExportDefaultFrom(identifier, from) {
  this.type = 'ExportDefaultFrom';
  this.start = -1;
  this.end = -1;
  this.identifier = identifier;
  this.from = from;
}

function ExportSpecifier(local, exported) {
  this.type = 'ExportSpecifier';
  this.start = -1;
  this.end = -1;
  this.local = local;
  this.exported = exported;
}

function Annotation(path, args) {
  this.type = 'Annotation';
  this.start = -1;
  this.end = -1;
  this.path = path;
  this.arguments = args;
}

function Comment(text) {
  this.type = 'Comment';
  this.start = -1;
  this.end = -1;
  this.text = text;
}